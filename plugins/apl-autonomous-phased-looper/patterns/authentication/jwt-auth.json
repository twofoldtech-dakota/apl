{
  "id": "sp_auth_jwt_001",
  "name": "JWT Authentication with Refresh Tokens",
  "version": "1.0.0",
  "type": "success_pattern",

  "task_type": "authentication",
  "applicable_when": [
    "jwt authentication",
    "token-based auth",
    "api authentication",
    "stateless authentication",
    "access token",
    "refresh token"
  ],

  "approach": "Use short-lived access tokens (15 minutes) paired with longer-lived refresh tokens (7 days). Store refresh tokens securely and rotate them on each use. Access tokens should be stateless JWTs; refresh tokens should be stored server-side for revocation capability.",

  "rationale": "Short-lived access tokens limit the window of vulnerability if compromised. Refresh tokens allow session persistence without frequent re-authentication. Server-side refresh token storage enables forced logout and session management.",

  "code_examples": {
    "token_generation": "import jwt from 'jsonwebtoken';\n\nconst ACCESS_TOKEN_EXPIRY = '15m';\nconst REFRESH_TOKEN_EXPIRY = '7d';\n\nexport function generateTokens(userId: string) {\n  const accessToken = jwt.sign(\n    { userId, type: 'access' },\n    process.env.JWT_SECRET!,\n    { expiresIn: ACCESS_TOKEN_EXPIRY }\n  );\n\n  const refreshToken = jwt.sign(\n    { userId, type: 'refresh' },\n    process.env.JWT_REFRESH_SECRET!,\n    { expiresIn: REFRESH_TOKEN_EXPIRY }\n  );\n\n  return { accessToken, refreshToken };\n}",

    "auth_middleware": "import { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\n\nexport function authMiddleware(req: Request, res: Response, next: NextFunction) {\n  const authHeader = req.headers.authorization;\n  if (!authHeader?.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'Missing authorization header' });\n  }\n\n  const token = authHeader.split(' ')[1];\n  try {\n    const payload = jwt.verify(token, process.env.JWT_SECRET!);\n    req.user = payload;\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid or expired token' });\n  }\n}",

    "refresh_endpoint": "export async function refreshTokenHandler(req: Request, res: Response) {\n  const { refreshToken } = req.body;\n\n  // Verify refresh token exists in database\n  const storedToken = await RefreshToken.findOne({ token: refreshToken });\n  if (!storedToken) {\n    return res.status(401).json({ error: 'Invalid refresh token' });\n  }\n\n  // Verify JWT signature\n  try {\n    const payload = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!);\n\n    // Rotate: delete old, create new\n    await storedToken.deleteOne();\n    const tokens = generateTokens(payload.userId);\n    await RefreshToken.create({ token: tokens.refreshToken, userId: payload.userId });\n\n    return res.json(tokens);\n  } catch (error) {\n    await storedToken.deleteOne(); // Invalidate on error\n    return res.status(401).json({ error: 'Invalid refresh token' });\n  }\n}"
  },

  "success_indicators": [
    "Access tokens expire in 15 minutes or less",
    "Refresh tokens are stored server-side",
    "Refresh tokens are rotated on each use",
    "Logout invalidates refresh tokens",
    "Separate secrets for access and refresh tokens"
  ],

  "anti_patterns_avoided": [
    "ap_auth_long_lived_token_001",
    "ap_auth_no_refresh_rotation_001"
  ],

  "related_patterns": [
    "sp_auth_bcrypt_001",
    "sp_api_error_handling_001"
  ],

  "tags": ["security", "authentication", "jwt", "tokens", "api"],

  "metadata": {
    "author": "APL Starter Library",
    "created": "2024-01-15",
    "success_count": 0,
    "frameworks": ["express", "fastify", "koa"],
    "languages": ["typescript", "javascript"]
  }
}
